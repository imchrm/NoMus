# Отчет о код-ревью: AquaBox (Smart Fridge / Автомат по продаже воды)

## 1. Обзор проекта
Проект "AquaBox" представляет собой прошивку для ESP32 на базе ESP-IDF, предназначенную для автоматизированного автомата по продаже воды. Прошивка управляет приемом платежей (купюроприемник, монетоприемник), подачей воды (датчик потока, управление насосом), мониторингом датчиков (TDS, DHT22), пользовательским интерфейсом (LCD 2004) и удаленной телеметрией/управлением через GSM (SIM800L) и MQTT.

## 2. Архитектура и структура

### Структура проекта
Проект имеет несколько нестандартную структуру для ESP-IDF.
- **Монолитный компонент `main`**: Почти весь исходный код (`.c`, `.cpp`, `.h`) находится непосредственно в директории `main/` или ее подпапках (`main/src`, `main/header`).
- **Рекомендация**: В ESP-IDF принято разделять функциональные модули (например, `sim800l`, `lcd`, `dht22`) на отдельные компоненты в корневой директории `components/`. Это способствует модульности, повторному использованию кода и упрощает `CMakeLists.txt`.

### Система сборки
- Используется CMake.
- Конфигурация управляется через `sdkconfig`.
- Учетные данные и специфические настройки (например, APN, брокер MQTT), по-видимому, смешаны: часть жестко зашита в коде, часть хранится в NVS.

## 3. Качество кода и лучшие практики

### Управление глобальным состоянием
- **Критическая проблема**: Проект сильно зависит от глобальных переменных (повсеместное использование `extern`).
    - Примеры: `total_cash`, `ozon_allowed`, `pump_running`, `imei`, `current_language`, `sum_totalcash`, `new_total`.
    - **Риск**: Это делает состояние системы непредсказуемым, сложным для отладки и подверженным состоянию гонки (race conditions), особенно в многозадачной среде FreeRTOS.
- **Рекомендация**: Инкапсулировать состояние внутри структур или объектов и передавать их через указатели контекста или использовать геттеры/сеттеры с надлежащей синхронизацией потоков.

### Многопоточность и потокобезопасность
- **Состояние гонки**: Многие глобальные переменные читаются и изменяются из нескольких задач (`LCD_Task`, `water_system_task`, `publish_task`, ISR) без явной защиты мьютексами в большинстве случаев.
- **Безопасность ISR**: Переменные, изменяемые в обработчиках прерываний (ISR), таких как `start_pressed`, `encashment_triggered`, как правило, объявлены как `volatile`, что хорошо. Однако сложная логика внутри ISR или отсутствие критических секций при чтении многобайтовых переменных (например, `int` или `float`, хотя на 32-битном ESP32 доступ выровнен, но операции чтение-модификация-запись не атомарны) могут быть рискованными.
- **Блокирующие вызовы**: Некоторые задачи используют длительные `vTaskDelay` или блокирующее чтение UART (например, в `sim800l.c`), что может затормозить работу других функций, если не управлять этим осторожно.

### Обработка ошибок
- **Непоследовательность**: Некоторые функции возвращают `bool` или `esp_err_t`, но возвращаемые значения часто игнорируются при вызове.
- **Логирование**: Хорошее использование макросов `ESP_LOG`, что помогает при отладке.

### Управление памятью
- **Динамическое выделение**: Частое использование `malloc` (например, в `sim800l.c` для MQTT пакетов).
    - **Риск**: Если пропустить `free()` в любой ветке выполнения (например, при ошибке), это приведет к фрагментации кучи и в конечном итоге к сбою (крашу).
    - **Проверка**: В `mqtt_publish` выделяются `response` и `mqtt_publish_packet`. Существуют пути выполнения с ошибками, где `free()` может быть пропущен или вызван дважды, если код не структурирован тщательно (хотя беглый осмотр показывает, что попытки освобождения памяти предпринимаются).
    - **Рекомендация**: Предпочтительнее использовать статическое выделение для буферов фиксированного размера или выделение на стеке (если позволяет размер стека), чтобы избежать фрагментации кучи.

## 4. Обзор конкретных модулей

### `main/main.cpp`
- **Точка входа**: Инициализирует NVS, GPIO и создает задачи.
- **Создание задач**: Создает множество задач (`LCD_Task`, `DHT_task`, `TDS_task`, `SIM800L_task`, `bill_acceptor_task`).
- **Проблема**: Логика "завершения" задач (`terminate_read_task` и т.д.) полагается на глобальные флаги и опросы, что менее надежно, чем использование уведомлений задач (task notifications) или правильных процедур завершения.

### `main/control_unit.c`
- **Логика**: Обрабатывает основную бизнес-логику (насос, цены, таймеры бездействия).
- **Сложность**: Файл довольно большой и смешивает управление оборудованием (GPIO, PCNT) с бизнес-правилами.
- **Сброс**: `perform_soft_reset` и `reset_transaction_state` — хорошие попытки управлять состоянием, но глубокая связанность с глобальными переменными затрудняет верификацию.

### `main/sim800l.c`
- **GSM**: Реализует драйвер для SIM800L через UART.
- **Блокировка**: Функции типа `send_at_command` являются блокирующими. Если модем зависнет или будет отвечать медленно, эта задача "встанет".
- **Парсинг**: Ручной парсинг AT-команд и JSON.
    - **Риск**: Используется `cJSON`, что хорошо, но ручные манипуляции со строками (например, `strstr`, арифметика указателей) для парсинга AT-команд чреваты ошибками.
    - **Безопасность буферов**: Использует `malloc` для буферов. `parse_incoming_json` парсит JSON, но также вызывает побочные эффекты (управление оборудованием) напрямую, нарушая принцип разделения ответственности.
- **MQTT**: Реализует собственный MQTT-клиент поверх AT-команд вместо использования `esp-mqtt`.
    - **Рекомендация**: Это сложный способ работы с MQTT. Рассмотрите использование PPPoS (PPP over Serial), чтобы поднять соединение SIM800 как сетевой интерфейс, а затем используйте стандартный клиент ESP-IDF MQTT. Это будет **намного** надежнее.

### `main/ota_update.c`
- **OTA**: Реализует обновление по воздуху через SIM800L.
- **Механизм**: Вручную загружает бинарный файл через AT-команды и записывает в раздел OTA.
- **Риск**: Это кастомная реализация. Если пакет потеряется или повредится, а ручная проверка контрольной суммы не сработает, это может привести к окирпичиванию устройства (хотя у ESP32 есть механизм отката/rollback). Использование PPPoS + нативного `esp_https_ota` было бы безопаснее и обеспечивало бы правильную поддержку стандартных протоколов/TLS.

### `main/bill_acceptor_ict104u.c` и `bill_acceptor.c`
- **Дублирование логики?**: Кажется, есть два файла для купюроприемников. `bill_acceptor.c` использует подсчет импульсов (PCNT), а `bill_acceptor_ict104u.c` использует UART.
- **Контекст**: Возможно, проект поддерживает несколько типов устройств или находится в процессе перехода.
- **Реализация**: Реализация UART использует конечный автомат (`state_billacceptor`), что является хорошим паттерном проектирования.

### `main/lcd.c`
- **Дисплей**: Управляет I2C LCD.
- **Производительность**: Использует `vTaskDelay` внутри циклов отрисовки. Если обновление дисплея происходит медленно, интерфейс может казаться "подвисающим".
- **Хардкод**: Строки для разных языков (TR, UZ, EN) жестко прописаны в блоках `if-else` внутри функции отрисовки.
    - **Рекомендация**: Используйте таблицу строк/словарь для локализации, чтобы отделить текст от логики.

## 5. Критические проблемы и безопасность

1.  **Учетные данные**: Пароли WiFi (если используются), APN и MQTT, похоже, жестко зашиты или управляются через NVS с откатом к значениям по умолчанию в коде.
    - *Риск*: Утечка исходного кода раскроет пароли инфраструктуры.
2.  **Жестко зашитый URL OTA**: URL и IP для OTA жестко прописаны в коде.
3.  **Обработа буферов**:
    - В `sim800l.c`, `mqtt_read_message` создает динамический буфер. Логика `realloc` (`while (len + r > capacity) { capacity *= 2; ... }`) в целом приемлема, но неограниченный рост при флуде потока может привести к крашу устройства (OOM).
    - В некоторых старых частях используется `sprintf` (хотя `snprintf` преобладает сейчас, что хорошо).
4.  **Сторожевой таймер (Watchdog)**: Вызывается `esp_task_wdt_reset()`, но убедитесь, что все циклы (особенно в `sim800l` при ожидании ответов AT) передают управление (yield) или сбрасывают WDT, иначе устройство будет неожиданно перезагружаться при плохом качестве сети.

## 6. Рекомендации

1.  **Рефакторинг в компоненты**: Переместите `sim800l`, `lcd`, `dht`, `tds`, `bill_acceptor` в `components/`.
2.  **Внедрение PPPoS**: Вместо ручного парсинга AT-команд для MQTT/HTTP, настройте интерфейс ESP-IDF PPPoS для SIM800L. Это позволит использовать стандартные сокеты Berkeley, `esp_mqtt` и `esp_https_ota`, которые гораздо надежнее и безопаснее (поддержка TLS).
3.  **Удаление глобальных переменных**: Создайте структуру `SystemState` и передавайте ее в задачи, используя потокобезопасную очередь (Queue) или мьютекс.
4.  **Локализация**: Вынесите все строковые литералы в отдельный заголовочный файл или файл ресурсов (`lang_en.h`, `lang_uz.h`) или структуру, чтобы очистить `lcd.c`.
5.  **Управление конфигурацией**: Используйте `Kconfig` для настройки на этапе сборки (например, пины по умолчанию, размеры буферов) и выделенный менеджер NVS для конфигурации времени выполнения.

## 7. Заключение
Проект функционален и реализует сложную бизнес-логику. Однако его монолитная структура и зависимость от глобального состояния делают его хрупким и сложным для поддержки или расширения. Кастомная реализация MQTT и OTA через UART (AT-команды) является самым слабым звеном; переход на PPPoS значительно улучшил бы стабильность и упростил код.
